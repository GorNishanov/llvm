Thoughts after discussion with Chandler, Hal and Richard.

* How to outline without CodeExtractor? 

  Run analysis similar to CodeExtractor
  Outline using cloning. Make them fastcc.
  Return values using insertvalue, extractvalue

  Constant *ConstantFolder::CreateExtractValue(Constant *Agg,
                               ArrayRef<unsigned> IdxList) const {
    return ConstantExpr::getExtractValue(Agg, IdxList);
  }

* do we need a branch on coro.begin?
  A: Frame Building need to allow consuming the data from prep block

* three-way or two-way coro.suspend?
  A: Two-way, there will be a branch from coro.init or coro.begin to make sure
     that return block is not discarded by SimplifyCFG in case we have an
     endless loop in the coroutine with suspend point inside
  A: Why not three way? It makes coroutine frame building harder. We don't want

* do we need coro-init?
  A: no

* no need to distinguish between final and normal coro.end

* no more coro.meta. Instead:

  CoroOutline creates constant {init-part, return-part, susp1, susp2, ...}
  CoroSplit create constant {type*, resume, destroy, cleanup}
    Though type is not strictly necessary as. Possibly array constants

@f.outlined = private unnamed_addr constant {...} {init, ret, fptr, ...}
@f.split =  private unnamed_addr constant [] [resume, destroy, cleanup]

   if not-array => pre-split

   use Align field to distinguish between NotReady for split and 

* can we inline parts after we calculated coroutine frame?
  P: Make analysis simpler, need some way to represent outlined save points
  Idea: Two level outlining?
  Even better idea. Move out coro.save and coro.suspend before reinlining

* CGSCC interaction:
  - Chandler said that it is OK to create functions in the same SCC during
    runSCC
  - Hal said that it is not OK to carry information about subfunctions in the
    metadata.
  - Richard confirmed that we do need to outline parts of the coroutine for
    protection against code motion.
  - Chandler suggested make RefreshSCC to recognize suspend points and pretend
    that they are devirtualizations points (or something better)


    do {
      DEBUG(if (Iteration)
              dbgs() << "  SCCPASSMGR: Re-visiting SCC, iteration #"
                     << Iteration << '\n');
      DevirtualizedCall = false;
      Changed |= RunAllPassesOnSCC(CurSCC, CG, DevirtualizedCall);
    } while (Iteration++ < MaxIterations && DevirtualizedCall);

Not interested yet in fixing a design bug in llvm.

CoroSplit:
  1st pass. Remove no-inline from Outliners (NotReadyForSplit)
  2nd pass. Split the coroutine, remove Coroutine attribute (ReadyForSplit)

* May not need CoroElide pass with the new model

  No, we need to. CoroElide needs to run after normal optimizations are done

  static Constant *ConstantArray::get(ArrayType *T, ArrayRef<Constant*> V);


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Args to spill:
Values to spill:
  %call8.loc = alloca i8, align 1 -- NO -- need better extract
  %call6 = call i32 @compute() #4 -- OK
  %2 = bitcast i32* %temp to i8* -- need to look to the source for rematerialize
  %3 = call token @llvm.coro.save() #4-- absolutely not

; Function Attrs: coroutine nounwind
define i8* @f() #0 {
  %call8.loc = alloca i8, align 1
  %call15.loc = alloca i8*, align 4
  %call3.loc = alloca i8*, align 4
  %cond.loc = alloca i8*, align 4
  %call.loc = alloca i8*, align 4
  %me = alloca %struct.DestroyMe, align 1
  %temp = alloca i32, align 4
  %call.i = call i8* @llvm.coro.alloc() #4
  %tobool.i = icmp eq i8* %call.i, null
  br i1 %tobool.i, label %cond.false.i, label %f_.AllocPart.exit

cond.false.i:                                     ; preds = %0
  %call1.i = call i32 @llvm_coro_size() #4
  %call2.i = call i8* @AllocCode(i32 %call1.i) #4
  br label %f_.AllocPart.exit

f_.AllocPart.exit:                                ; preds = %0, %cond.false.i
  %cond.i = phi i8* [ %call2.i, %cond.false.i ], [ %call.i, %0 ]
  %call3.i = call i8* @PrepCode(i8* %cond.i) #4
  store i8* %call.i, i8** %call.loc, align 4
  store i8* %cond.i, i8** %cond.loc, align 4
  store i8* %call3.i, i8** %call3.loc, align 4
  %call.reload = load i8*, i8** %call.loc, align 4
  %cond.reload = load i8*, i8** %cond.loc, align 4
  %call3.reload = load i8*, i8** %call3.loc, align 4
  %call4 = call i8* @llvm.coro.start(i8* %cond.reload, i8* %call.reload, i32 0, i8* null, i8* bitcast ({ void (i8**, i8**, i8**)*, void ()*, void (i8*, %struct.DestroyMe*, i8**)*, void (i8*, i8*)* }* @f.outlined to i8*))
  %tobool5 = icmp eq i8* %call4, null
  br i1 %tobool5, label %5, label %1

; <label>:1:                                      ; preds = %f_.AllocPart.exit
  call void @Whatever(i32 1) #4
  %call6 = call i32 @compute() #4
  %2 = bitcast i32* %temp to i8*
  br label %CoroSave

CoroSave:                                         ; preds = %1
  %3 = call token @llvm.coro.save() #4
  br label %AfterCoroSave

AfterCoroSave:                                    ; preds = %CoroSave
  call void @Subscribe(i8* null, i8* %2) #4
  %call8.i = call i8 @llvm.coro.suspend(token %3, i1 false) #4
  store i8 %call8.i, i8* %call8.loc, align 1
  %call8.reload = load i8, i8* %call8.loc, align 1
  %not.cond1 = icmp eq i8 %call8.reload, 0
  br i1 %not.cond1, label %4, label %cleanup.cont

cleanup.cont:                                     ; preds = %AfterCoroSave
  call void @handleValue(i32 %call6) #4
  call void @Whatever(i32 2) #4
  br label %4

; <label>:4:                                      ; preds = %AfterCoroSave, %cleanup.cont
  %call10.i = call i8* @llvm.coro.free(i8* null) #4
  %tobool11.i = icmp eq i8* %call10.i, null
  br i1 %tobool11.i, label %CoroEnd, label %if.then12.i

if.then12.i:                                      ; preds = %4
  %call13.i = call i32 @llvm_coro_size() #4
  call void @FreeCode(i8* nonnull %call10.i, i32 %call13.i) #4
  br label %CoroEnd

CoroEnd:                                          ; preds = %4, %if.then12.i
  call void @llvm.coro.end(i8* null, i1 true)
  br label %AfterCoroEnd

AfterCoroEnd:                                     ; preds = %CoroEnd
  br label %5

; <label>:5:                                      ; preds = %f_.AllocPart.exit, %AfterCoroEnd
  %call15.i = call i8* @RetCode(i8* %call3.reload) #4
  call x86_thiscallcc void @"\01??1DestroyMe@@QAE@XZ"(%struct.DestroyMe* nonnull %me) #4
  store i8* %call15.i, i8** %call15.loc, align 4
  %call15.reload = load i8*, i8** %call15.loc, align 4
  ret i8* %call15.reload
}

