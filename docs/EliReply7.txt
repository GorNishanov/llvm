Hi Eli:

>> Err... I guess nothing; sorry, I got myself confused.  

That is my fault :-). I confused myself in the beginning where I was trying to
treat coro.suspend + cond.branch pair as a terminator and was looking for 
branches. You showed me the way... Just ignore the branches and represent
the control flow cleanly and SimplifyCFG will take care of the rest :-).

>> You might run into problems with allocas: 

>>   x = alloca...
>>
>> block1:
>>   suspend
>>   ; increment could get moved here.
>>   switch (resume, destroy, return)
>>
>> resume:
>>   x += 1 ; load + inc + store
>>   [...]
>>
>> destroy:
>>   x += 1 ; load + inc + store
>>   [...]
>>
>> return:
>>   (don't touch x)
>>   [...]

Yep. You are right. I think I can fix the alloca case, not sure if there is an
equivalent hoisting for things other than load and stores.

Alloca case fix:

>> return:
>>   call void @llvm.coro.end() 
>>   (don't touch x)
>>   [...]

In the alloca case, coro.end can examine any memory including stack, so moving
x += 1, will become observable in return block and thus hoisting should not be
done as it will alter semantics. But, I am not sure it will cover all possible
cases.

Okay. One last attempt before getting to your "Two Function" idea :-).
Slight variation on above.

Still one function (coro.end gets an i1 %retblock parameter )
=============================================================

Return block starts with:

>> return:
>>   call void @llvm.coro.end(i1 true) 
>>   (don't touch x)
>>   [...]

In 'f', coro.suspend is replaced with 
  br <to exactly where llvm.coro.end(i1 true)> is .

In this case three way coro.suspend seems wasteful. I can bring coro.fork back
and make coro.suspend two way. (Need some way to keep return block reachable
in case coroutine body contains an endless loop).

Almost two functions (coro.fork(), coro.suspendO() same as in original proposal)
================================================================================

CoroEarly pass which runs at EP_EarlyAsPossible will extract f.start using
coro.fork as a guide (since false branch bypasses the coroutine body).

Coroutine will now travel as two functions until CoroSplit will get to f.start
(Probably will use 'coroutine' attribute on a function to indicate that it 
requires CoroSplit to munge on it.)

I am still hoping we can find a solution without requiring to separate f.start
out. Seems like a huge hammer to avoid undesirable code motion / hoisting.

(I really hope that @coro.end(i1 %retblock) approach can work)

Thanks a lot, Eli, for your help with the design!
Gor



