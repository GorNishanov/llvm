I think I got it. Original model (with coro.fork and two-way coro.suspend)
will work with a tiny tweak.

In the original model, I was replacing coro.suspend with br %return in original
function. The problem was coming from potential phi-nodes introduces into
return block during optimizations.

Let's make sure that there is only entry into the return block.
In the original model, ReturnBB had two entries, one from coro.fork,
another from fall-through from the delete block.

  T coro() {
    %mem = malloc(...);
    if (!coro.fork()) {
      Body Of The Coroutine
      With Suspends and All The Fun
  DeleteBB:
      free(%mem)
      coro.end() 
    }
  ReturnBB:  
    return some_code_creating_T();
  }

In the original model,
  coro.end is replaced with `no-op` in start, 'ret void' in clones (*)
  suspend is replaced with `br %return` in start, 'ret void' in clones

Let's tweak it. Add an i1 %fallthru parameter to coro.end. Now the behavior is:
  in clones coro.end behaves as before: replaced with 'ret void' (*)
  in original:
    coro.end(false) => no-op (as before). (*)
    coro.end(true) => 'br %return'

Now the body of the coroutine will look like this:

T coro() {
    %mem = malloc(...);
    if (coro.fork()) {
ReturnBB:    
      return some_code_creating_T();
    }
    Body Of The Coroutine
    With Suspends and All The Fun
DeleteBB:
    free(%mem)
    coro.end(true) 
    UNREACHABLE
  }

Now I don't think any code that has side effects can sneak up from the
"Body of The Coroutine" into ReturnBB. So we are good, right?

Gor

-----------------
(*) There are two uses for coro.end. One is for the fallthrough point in 
the delete block. Another, in unwind code responsible for cleanup in
the original function if there is an exception **BEFORE** coroutine had a 
chance to suspend.

coro.end in unwind blocks is replaced with appropriate 'unwind to caller'
instruction, cutting the rest out.
