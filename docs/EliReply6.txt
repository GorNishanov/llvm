Hi Eli:

>> Err... I guess nothing; sorry, I got myself confused.  

That is my fault :-). I confused myself in the beginning where I was trying to
treat coro.suspend + cond.branch pair as a terminator and was looking for 
branches. You showed me the way... Just ignore the branches and represent
the control flow cleanly and SimplifyCFG will take care of the rest :-).

>> You might run into problems with allocas: 

Yep. Slitting the coroutine is an easy part.
Building up the coroutine frame and deciding what should go there is harder.

Coroutine frame building algorithm has two parts: 
  * Deal with allocas
  * Deal with virtual registers.

Alloca part
-----------

  Step 1: Compute the blocks that will end up in resume and destroy
  Step 2: Classify alloca into three buckets
    Start Only: Only used in start
    Resume Only: Only used in resume/destroy
    Shared: Used in both (or escaped)
  Step 3: Put all shared values in the coroutine frame, RAUW shared allocas with 
    GEPs from coroutine frame
  Step 4: Move all resume only allocas to the new entry block in resume/destroy


  (Future Work)

  Step X: 
    Utilize lifetime information for shared allocas to decide how to pack them
    tightly in coroutine frame. At the moment I throw away lifetime intrinsics.
  Step X+1:
    Deal with variable allocas (chaining them to the coroutine frame using
    the same allocation and deallocation routines used for coroutine frame 
    itslef)

Virtual Register part
---------------------

  Step 1: Precompute block relationship X(B1,B2), when B1 dominates B2 and there
    is a path from B1 to B2 that crosses a suspend point.
  Step 2: 
    Check if a path from a use of value in a resume/destroy block to a 
    definition crosses a suspend point, ie X(Bd,Bu) == true, where
      Bu is a block with the use
      Bd is a block with the definition or an entry block if d is func argument
  Step 3:
    Check if we already have value 'd' in the coroutine frame, if so, replace
    the use with GEP from 

Let's see how it will work in your example:

>>   x = alloca...
>>      [...]
>> block1:
>>   suspend
  ; increment could get moved here.
  switch (resume, destroy, return)

resume:
  x += 1
   [...]

destroy:
  x += 1
   [...]

return:
  (don't touch x)
  [...]

The increment is only supposed to execute once, but instead executes twice.

This isn't a great example... and I'm not sure issues are limited to
allocas... but that's the idea, anyway.

-Eli
